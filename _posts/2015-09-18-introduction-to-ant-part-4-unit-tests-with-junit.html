---
layout: post
status: publish
published: true
title: 'Introduction to Ant Part 4: Unit Tests with JUnit'
author:
  display_name: Shrimp
  login: shrimp
  email: shrimp@shrimpworks.za.net
  url: http://shrimpworks.za.net/
author_login: shrimp
author_email: shrimp@shrimpworks.za.net
author_url: http://shrimpworks.za.net/
wordpress_id: 861
wordpress_url: http://shrimpworks.za.net/?p=861
date: '2015-09-18 08:24:28 +0200'
date_gmt: '2015-09-18 06:24:28 +0200'
categories:
- Development
tags:
- Tutorials
- Java
- Ant
---
<p><img src="http://shrimpworks.za.net/wp-content/uploads/2015/09/102857-150x150.png" width="200" height="200" class="alignleft" /> Now that we have <a href="http://shrimpworks.za.net/2015/08/07/introduction-to-ant-part-3-dependency-management-with-ivy/">dependency management with Ivy</a> working along with everything else covered before, we've covered almost everything required to start building <em>real</em> projects with Ant.</p>
<p>Another thing any <em>real</em> project should have, is unit tests. Thankfully, using the scaffolding already put in place in earlier parts of this series, integrating a <a href="http://junit.org/">JUnit</a> testing task into our existing build script is really straight-forward.</p>
<p><a id="more"></a><a id="more-861"></a></p>
<p>The code for this part of the tutorial is <a href="https://github.com/shrimpza/ant-tutorial/tree/master/part04">available on GitHub</a>. To see what's new and changed, <a href="https://github.com/shrimpza/ant-tutorial/commit/e893782d64e1a93453d0e8fd1b331cf86e9c9eb9">this diff is quite useful</a>. I'll break down what's in that diff:</p>
<pre class="prettyprint"><code class="language-xml">    <!-- basic paths --> 
    ...
    <property name="test.dir" location="test"/>
    ...
</code></pre>
<p>To start off, adding a new property to keep track of where the test classes will live.</p>
<p>Your directory tree will look something like this:</p>
<pre><code>  Project Root
   - src
     - yourpackage
       - YourClass.java
   - test
     - yourpackage
       - YourClassTest.java
</code></pre>
<pre class="prettyprint"><code class="language-xml">    ...
    <property name="build.test.dir" location="${build.dir}/test"/>
</code></pre>
<p>Similarly, the output directory for compiled/built test sources.</p>
<pre class="prettyprint"><code class="language-xml">    <path id="test.classpath">
        <fileset dir="${lib.dir}" includes="test/*.jar"/>
        <pathelement path="${build.test.dir}"/>
    </path>
</code></pre>
<p>Defining a classpath dedicated to tests, which includes all <a href="https://ant.apache.org/ivy/">Ivy</a>-downloaded libraries for testing, as well as th actual compiled test classes themselves.</p>
<p>It may not seem immediately useful to have a dedicated directory/path for testing libraries, however before long, you'll likely come across various libraries and frameworks (aside form JUnit itself) which assist with and facilitate things like mocking, in-memory database testing, etc., which you'll need to exclude from your distributable builds. It's neater to manage these dependencies separately.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Build test classes -->
    <target name="build-tests" depends="build" description="compile test source files">
        <mkdir dir="${build.test.dir}"/>

        <javac srcdir="${test.dir}" destdir="${build.test.dir}" includeantruntime="false" debug="on">
            <classpath refid="default.classpath"/>
            <classpath refid="test.classpath"/>
        </javac>
    </target>
</code></pre>
<p>This looks nearly identical to <a href="http://shrimpworks.za.net/2015/07/07/introduction-to-ant-part-1-a-basic-build/">the <code>build</code> target defined back in part 1</a>, with some changes to the variables used - this time making reference to the test paths and properties.</p>
<p>It's also added the test <a href="https://ant.apache.org/manual/using.html#path">classpath</a> to the <a href="https://ant.apache.org/manual/Tasks/javac.html">javac task</a> in addition to the <code>default.classpath</code> which will include the built contents of the main <code>src</code> directory.</p>
<p>You may also note that this target depends on the <code>build</code> target - the test classes will depend on the primary source files being built before they can be.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Run tests -->
    <target name="run-tests" depends="build-tests" description="run junit tests">
        <junit printsummary="yes" fork="yes" haltonfailure="no"
                errorproperty="tests.errors" failureproperty="tests.failures">
            <classpath refid="default.classpath"/>
            <classpath refid="test.classpath"/>

            <formatter type="plain" usefile="false"/>
            
            <batchtest>
                <fileset dir="${test.dir}">
                    <include name="**/*Test.java"/>
                </fileset>
            </batchtest>
        </junit>
    </target>
</code></pre>
<p>The build target which actually executes the <a href="https://ant.apache.org/manual/Tasks/junit.html">junit task</a> to run our test cases.</p>
<p>A couple of attributes are being set here, but most importantly within this particular script are <code>errorproperty</code> and <code>failureproperty</code>. Ant will set properties with the names specified in the event of a test error or failure. We can use these in the <code>test</code> target described below to alter the behavior of the script based on what happened within the tests.</p>
<p>The <code>formatter</code> element in use here is indicating we want plain-text output, and it should only be printed to the console, rather than sent to a file. Although I'm not using it in this particular script, a common use-case would be to set the format <code>type</code> to <code>xml</code>, and use the <code>todir</code> attribute of the <code>batchtest</code> element to have the test reports written to XML files, which may then be presented as fancy HTML reports, usually by a build server such as <a href="http://jenkins-ci.org/">Jenkins</a>, which is incredibly useful.</p>
<p>Finally, we are using the <code>batchtest</code> tag to indicate we want to run a <em>batch</em> of tests. The <code>fileset</code> provided is using the test source directory we defined, and is only going to process test classes whose name ends in <code>...Test.java</code>. This is useful since you may want to include helper, utility and mock classes within the test sources path, which typically JUnit would choke on, as it looks for tests in <em>all</em> provided files within the <code>fileset</code> provided.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Run tests, exiting with status code 1 on error, or 2 on test failure -->
    <target name="test" depends="run-tests" description="run junit tests, and fail the build on error or failure">
        <fail if="tests.errors" message="Error encountered while executing tests" status="1"/>
        <fail if="tests.failures" message="Tests failed" status="2"/>
    </target>
</code></pre>
<p>The final change to <code>build.xml</code>, the actual <code>test</code> target itself.</p>
<p>Used in combination with the attributes passed to the <code>junit</code> task defined in the <code>run-tests</code>, this target allows us to fail the build with varying exit codes to allow automated build tools to react or report differently, based on the outcome of the tests, without needing to parse logs or the test reports. Mostly this is a convenience feature.</p>
<p>That's it for the <code>build.xml</code> changes, now a minor adjustment to <code>ivy.xml</code> to download JUnit for us:</p>
<pre class="prettyprint"><code class="language-xml">    ...
        <conf name="test" extends="default"/>
    ...
 
    <dependencies>
        ...
        <!-- test dependencies -->
        <dependency org="junit" name="junit" rev="4.11" conf="test->default"/>
    ...
</code></pre>
<p>Pretty straight-forward, with the addition of the <code>test</code> configuration. <a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile/configurations.html">Ivy Configurations</a> offer a way of grouping different sets of dependencies for different purposes. In our case, the <code>test</code> configuration can be used for all test-related third-party dependencies, <em>including</em> JUnit itself! For example if you were developing a database application, and wanted your tests to run against an in-memory Derby database rather than something external, you'd configure that dependency as part of the <code>test</code> configuration, which would mean it would not be included in your <code>default</code> libraries used by your (probably) redistributable code.</p>
<p>That's about all there is to it. You can now execute the following to run unit tests in your project:</p>
<pre class="prettyprint"><code class="language-xml">$ ant test
</code></pre>
<hr/>
<p>Other parts in this series:</p>
<p><a href="http://shrimpworks.za.net/2015/07/07/introduction-to-ant-part-1-a-basic-build/">Part 1: A Basic Build</a><br />
<a href="http://shrimpworks.za.net/2015/07/11/introduction-to-ant-part-2-runnable-jar-file/">Part 2: Runnable Jar File</a><br />
<a href="http://shrimpworks.za.net/2015/08/07/introduction-to-ant-part-3-dependency-management-with-ivy/">Part 3: Dependency Management with Ivy</a></p>
