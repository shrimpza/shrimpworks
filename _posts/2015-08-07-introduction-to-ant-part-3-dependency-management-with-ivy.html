---
layout: post
status: publish
published: true
title: 'Introduction to Ant Part 3: Dependency Management with Ivy'
author:
  display_name: Shrimp
  login: shrimp
  email: shrimp@shrimpworks.za.net
  url: http://shrimpworks.za.net/
author_login: shrimp
author_email: shrimp@shrimpworks.za.net
author_url: http://shrimpworks.za.net/
wordpress_id: 829
wordpress_url: http://shrimpworks.za.net/?p=829
date: '2015-08-07 10:20:45 +0200'
date_gmt: '2015-08-07 08:20:45 +0200'
categories:
- Development
tags:
- Tutorials
- Java
- Ant
---
<p><img src="http://shrimpworks.za.net/wp-content/uploads/2015/08/102856-150x150.png" width="200" height="200" class="alignleft" /> So far, we've covered the basics of <a href="http://shrimpworks.za.net/2015/07/07/introduction-to-ant-part-1-a-basic-build/">creating a re-distributable <code>.jar</code> package</a> suitable for use as a library, and <a href="http://shrimpworks.za.net/2015/07/11/introduction-to-ant-part-2-runnable-jar-file/">building a Jar file which can be run</a> by a user or server process.</p>
<p>A major part of any non-trivial application these days is the inclusion and re-use of 3rd party libraries which implement functionality your applications require. When a project starts, it's probably easy enough to manually drop the odd <code>jar</code> library into a <code>lib</code> directory and forget about it, but maintaining a large application which depends on many libraries, which in turn depend on additional libraries for their own functionality, it can quickly turn into a nightmare to manage.</p>
<p>To solve this problem, many dependency management tools have been introduced, most notably, <a href="https://maven.apache.org/">Apache Maven</a>. Maven however, is so much more than just a dependency management tool, and is actually intended to manage your entire project structure. I believe however, the combination of Ant and Ivy provides far more flexibility, extensibility and control over your build and dependency management processes.</p>
<p>So, let's integrate <a href="https://ant.apache.org/ivy/">Apache Ivy</a> into our Ant script as we left it in <a href="http://shrimpworks.za.net/2015/07/11/introduction-to-ant-part-2-runnable-jar-file/">part 2</a>.</p>
<p><a id="more"></a><a id="more-829"></a></p>
<p>For starters, the <a href="https://github.com/shrimpza/ant-tutorial/tree/master/part03">code for this part is available in GitHub</a> once again. I'll walk through the <a href="https://github.com/shrimpza/ant-tutorial/commit/848679fdb39786f07fc9053fbeef2957fd8e1a6b">diff of what's changed since part 2</a>.</p>
<p>As mentioned in my post on <a href="http://shrimpworks.za.net/2015/06/29/using-findbugs-with-ant/">FindBugs integration with Ant</a>, I'm a strong believer in the idea that a developer (or user) should be able to check out or download a project's code and be able to build and start working on the code with minimal time and effort investment. This is especially useful in a work environment where you have many developers working on projects, and time spent flapping around with setting up build environments has a direct impact on timelines and team output.</p>
<p>To this end, our Ant script will be responsible for downloading and configuring Ivy as part of the regular build process, meaning a new developer or user simply has to get your code and have Ant installed - all additional features and capabilities of the build process should be "self maintaining". I believe this is another testament to Ant's flexibility.</p>
<p>Let's go through the changes to our <code>build.xml</code> file since part 2:</p>
<p><strong>build.xml changes:</strong></p>
<pre class="prettyprint"><code class="language-xml"><project name="hello-world" default="dist" basedir="." xmlns:ivy="antlib:org.apache.ivy.ant">
</code></pre>
<p>Start by adding the <code>ivy</code> XML namespace.</p>
<pre class="prettyprint"><code class="language-xml">    <property name="lib.dir" location="lib"/>
</code></pre>
<p>Since we're going to be incorporating additional libraries into our project, this is a new configuration option which we'll use to point to where we want them stored. This will map to the <code>project-root/lib</code> directory.</p>
<pre class="prettyprint"><code class="language-xml">    <path id="default.classpath">
        <fileset dir="${lib.dir}" includes="default/*.jar"/>
        <pathelement path="${build.src.dir}"/>
    </path>
</code></pre>
<p>Again, since we're incorporating additional libraries, the new <code>lib</code> directory needs to be added to the class-path so dependencies can be made use of at compile time. The new <a href="https://ant.apache.org/manual/Types/fileset.html">Fileset</a> tag is pointing out the location of the "default" dependencies (more on what "default" refers to later - see the explanation on the addition of the <code>ivy.xml</code> file), and is including all <code>.jar</code> packages in that location.</p>
<pre class="prettyprint"><code class="language-xml">    <path id="dist.classpath">
        <fileset dir="${dist.dir}" includes="lib/*.jar"/>
    </path>
</code></pre>
<p>Defining another new class-path. As you'll see later on in the updated <code>dist</code> build target, this is used to add libraries to our application's manifest file (the manifest includes a list of all packages and paths to include in the class-path).</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Ivy configuration -->
    <property name="ivy.install.version" value="2.4.0" />
    <property name="ivy.home" value="${user.home}/.ant" />
    <property name="ivy.jar.dir" value="${ivy.home}/lib" />
    <property name="ivy.jar.file" value="${ivy.jar.dir}/ivy.jar" />
</code></pre>
<p>As the comment tag suggests, these are a couple of options used for configuring Ivy usage.</p>
<p>Firstly, the version is defined as it's own variable. Later, this will be built into a download URL, but defining it as a separate value makes it easier to configure.</p>
<p>Then, the <code>ivy.home</code> property sets where the base path to where we want Ivy to live. I've set this to the <code>.ant</code> directory in the user's home directory.</p>
<p><code>ivy.jar.dir</code> is where Ivy will be downloaded to, and <code>ivy.jar.file</code> is the path to the actual <code>ivy.jar</code> file. Also note how the paths are built up from various properties, so it can be quite easily customised.</p>
<p>Finally, <code>ivy.lib.dir</code> references the library directory, and is used as the root target directory for dependencies Ivy downloads.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Ivy download -->
    <target name="ivy-download">
        <mkdir dir="${ivy.jar.dir}"/>
        <get src="http://repo2.maven.org/maven2/org/apache/ivy/ivy/${ivy.install.version}/ivy-${ivy.install.version}.jar" 
             dest="${ivy.jar.file}" usetimestamp="true"/>
    </target>
</code></pre>
<p>Now that everything is set up and ready, Ivy itself can be downloaded. The download operation is defined as it's own <a href="https://ant.apache.org/manual/targets.html">build target</a>, so it can be performed independently of everything else in the script (this is very useful for testing), as well as be used as a dependency by targets which actually use Ivy.</p>
<p>It starts by <a href="https://ant.apache.org/manual/Tasks/mkdir.html">creating the target directory</a> where the Ivy library will be downloaded to, and then using <a href="https://ant.apache.org/manual/Tasks/get.html">Ant's get task</a> to perform a download of the desired Ivy version, to the previously configured download location. The <code>usetimestamp</code> attribute of the <code>get</code> task will skip re-downloading the library on every build if it hasn't been modified on the remote server.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Ivy initialisation -->
    <target name="ivy-init" depends="ivy-download">
        <path id="ivy.lib.path" path="${ivy.jar.file}"/>
        <taskdef resource="org/apache/ivy/ant/antlib.xml"
                 uri="antlib:org.apache.ivy.ant" classpathref="ivy.lib.path"/>
    </target>
</code></pre>
<p>Again, a small target dedicated to a single function. This time, we need to make Ant aware that an Ivy task is available, and this is done using the <a href="https://ant.apache.org/manual/Tasks/taskdef.html">taskdef task</a>. Another <code>path</code> is defined here as well, used to inform Ant where it may find the task that is being defined.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Ivy dependency resolution -->
    <target name="ivy-resolve" depends="ivy-init" description="retrieve dependencies with ivy">
        <ivy:retrieve pattern="${lib.dir}/[conf]/[artifact]-[revision](-[classifier]).[ext]" />
    </target>
</code></pre>
<p>At last, we can use Ivy to download some dependencies! The <code>pattern</code> attribute in the <a href="https://ant.apache.org/ivy/history/latest-milestone/use/retrieve.html">retrieve task</a> tells Ivy where it should download <em>artefacts</em> ("libraries" and associated source and javadoc packages) to. You can find out <a href="https://ant.apache.org/ivy/history/latest-milestone/concept.html#patterns">more about patterns in the Ivy reference</a>. </p>
<p>Note that the "<code>classifier</code>" place-holder does not appear to be documented clearly anywhere, and refers to a Maven package classifier - for example "sources" or "javadocs", which may accompany a library.</p>
<p>The end result of the <code>retrieve</code> task should end up (assuming some dependencies have been defined) in a structure something like <code>project-root/lib/default/some_lib-1.0.jar</code>.</p>
<pre class="prettyprint"><code class="language-xml">    <!-- Simple source build -->
    <target name="build" depends="ivy-resolve" description="compile source">
</code></pre>
<p>Change to the original <code>build</code> target, set to depend on the previously described <code>ivy-resolve</code> task.</p>
<p>From this point, the target dependencies look something like the following:</p>
<ul>
<li><code>build</code> (compile .java sources) depends on:</li>
<li><code>ivy-resolve</code> (download libraries which will be needed to compile sources), which depends on:</li>
<li><code>ivy-init</code> (set up and define the Ivy tasks used to download), which in turn depends on:</li>
<li><code>ivy-download</code> (download Ivy library itself) before anything else.</li>
</ol>
<pre class="prettyprint"><code class="language-xml">    <!-- Build distribution -->
    <target name="dist" depends="build" description="generate distribution">
        <mkdir dir="${dist.dir}/lib"/>

        <copy todir="${dist.dir}/lib">
            <fileset dir="${lib.dir}/default" includes="*.jar" erroronmissingdir="false">
                <exclude name="**/*-javadoc.jar"/>
                <exclude name="**/*-sources.jar"/>
            </fileset>
        </copy>

        <manifestclasspath property="dist.manifest.classpath" jarfile="${dist.dir}/${ant.project.name}.jar">
            <classpath refid="dist.classpath" />
        </manifestclasspath>

        <jar jarfile="${dist.dir}/${ant.project.name}.jar">
            <manifest>
                <attribute name="Main-Class" value="${main.class}"/>
                <attribute name="Class-Path" value="${dist.manifest.classpath}"/>
            </manifest>
            <fileset dir="${build.src.dir}" />
            <zipfileset dir="${src.dir}" excludes="**/*.java"/>
        </jar>
    </target>
</code></pre>
<p>Here's the whole revised <code>dist</code> target, which has grown substantially. A number of new elements have been added;</p>
<p>Firstly, the <code>mkdir</code> task has been updated to simply create the <code>/lib</code> directory within the already-configured <code>${dist.dir}</code>. It makes parent directories as needed, so we don't need a separate <code>mkdir</code> for each.</p>
<p>The addition of <a href="https://ant.apache.org/manual/Tasks/copy.html">the copy task</a> here copies all <em>default</em> libraries (that is, not ones used for testing, coverage, or other configurations - more on these kinds of configurations in another episode). It's also explicitly excluding any javadoc or source packages from the distributable files - you typically don't want to include these in your distribution.</p>
<p>Another new addition is the <code>manifestclasspath</code>, which is referencing the <code>dist.classpath</code> we defined earlier, to make sure that the contents of the <code>dist/lib</code> directory are included in the runtime class-path. This is referenced by a new <code>attribute</code> named <code>Class-Path</code> in the <a href="https://ant.apache.org/manual/Tasks/jar.html"><code>jar</code> task</a>'s <code>manifest</code>.</p>
<pre class="prettyprint"><code class="language-xml">        <delete dir="${lib.dir}"/>
</code></pre>
<p>Finally, since we created the <code>lib</code> directory as part of the build process, we need to be sure to clean it up as part of the <code>clean</code> target.</p>
<p><strong>New file: ivy.xml:</strong></p>
<p>At last, we arrive at the actual <a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile.html">Ivy file</a> itself. Since we haven't explicitly declared an <a href="https://ant.apache.org/ivy/history/latest-milestone/use/resolve.html">Ivy resolve task</a> pointing to a specific Ivy file (via the <code>file</code> attribute on the <code>resolve</code> task), Ivy will by default use a file named <code>ivy.xml</code>, which is what we're providing in this instance:</p>
<pre class="prettyprint"><code class="language-xml"><?xml version="1.0" encoding="UTF-8"?>
<ivy-module version="2.4">
    <info organisation="net.shrimpworks" module="${ant.project.name}"/>

    <configurations>
        <conf name="default" />
    </configurations>

    <dependencies>
        <!-- project dependencies -->
        <dependency org="org.slf4j" name="slf4j-api" rev="1.7.12" conf="default" />
        <dependency org="org.slf4j" name="slf4j-simple" rev="1.7.12" conf="default" />
    </dependencies>
</ivy-module>
</code></pre>
<p>Let's run through the file briefly:</p>
<p>First up, <a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile/info.html">info</a>, which describes some simple properties of the project. This is not immediately useful to us, but will be for publishing artefacts, and more intricate dependency management (where the <code>branch</code> and <code>status</code> attributes prove particularly useful).</p>
<p><a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile/configurations.html">Configurations</a> are one of the primary tools Ivy gives us for organising primarily the dependencies used in different types of builds (for example if we're running unit tests, we require additional dependencies which we don't want included as part of our standard build - configurations allow us to separate out these sorts of things), as well as artefact publishing. You can <a href="https://ant.apache.org/ivy/history/latest-milestone/concept.html#configurations">read a bit more about Configurations</a>.</p>
<p>In this case, the inclusion of the <code>configurations</code> is not strictly required, since we're just redefining the <code>defalut</code> configuration, which exists by default anyway. In another part of this series, it will get much more useful.</p>
<p>At last, what we're actually after after all this, are <a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependencies.html">the dependencies themselves</a>. There are many attributes which can be <a href="https://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html">defined per dependency</a> within this collection. The key requirements are the <code>org</code>, <code>name</code> and <code>rev</code>.</p>
<p>Often when reviewing the usage documentation for a 3rd party project you want to use as a dependency, they will provide a Maven dependency, containing the fields <code>groupId</code>, <code>artifactId</code> and <code>version</code>, which map directly to Ivy's <code>org</code>, <code>name</code> and <code>rev</code>.</p>
<p>In fact, by default Ivy will download dependencies from the <a href="https://search.maven.org/">Central Maven Repository</a>, giving you immediate access to all the same content and libraries.</p>
<p>In my example, I'm downloading some simple <a href="http://slf4j.org/">SLF4J</a> resources which <a href="https://github.com/shrimpza/ant-tutorial/blob/master/part03/src/net/shrimpworks/ant/Main.java">my Main class</a> requires to build.</p>
<p><strong>In Summary</strong></p>
<p>When you execute an <code>ant build</code> or <code>ant dist</code> now, the following actions are going to take place:</p>
<ol>
<li>Ant will download the Ivy package if it doesn't exist or is out of date (<code>ivy-download</code>)</li>
<li>Ivy's Ant task will be registered and made available (<code>ivy-init</code>)</li>
<li>Dependencies will be resolved and downloaded (<code>ivy-resolve</code>)</li>
<li>Source code will be compiled, with the downloaded dependencies on the class-path (<code>build</code>)</li>
<li>Compiled source and downloaded libraries will be packaged for distribution (<code>dist</code>)</li>
</ol>
<p>This step turned out significantly chunkier than expected, but hopefully it makes sense and is digestible. What we have here is a fairly clean and simple Ivy implementation, and we'll be building on top of this for the next edition of this epic saga. In the mean time, I highly recommend following some of the task and configuration elements I've linked throughout this document, there are many fun and interesting knobs and dials to play with.</p>
<hr/>
<p>Other parts in this series:</p>
<p><a href="http://shrimpworks.za.net/2015/07/07/introduction-to-ant-part-1-a-basic-build/">Part 1: A Basic Build</a><br />
<a href="http://shrimpworks.za.net/2015/07/11/introduction-to-ant-part-2-runnable-jar-file/">Part 2: Runnable Jar File</a><br />
<a href="http://shrimpworks.za.net/2015/09/18/introduction-to-ant-part-4-unit-tests-with-junit/">Part 4: Unit Tests with JUnit</a></p>
