---
layout: post
status: publish
published: true
title: Simple HTTP Server in Java
author:
  display_name: Shrimp
  login: shrimp
  email: shrimp@shrimpworks.za.net
  url: http://shrimpworks.za.net/
author_login: shrimp
author_email: shrimp@shrimpworks.za.net
author_url: http://shrimpworks.za.net/
wordpress_id: 524
wordpress_url: http://shrimpworks.za.net/?p=524
date: '2013-12-17 21:28:42 +0200'
date_gmt: '2013-12-17 19:28:42 +0200'
categories:
- Development
tags:
- Java
- HTTP
- Service
---
<p>Some thing I've been using for a while, and which recently became useful at work as well, is a simple HTTP service written in plain Java with existing JRE functionality, using an <a href="http://docs.oracle.com/javase/7/docs/jre/api/net/httpserver/spec/com/sun/net/httpserver/HttpServer.html">HttpServer</a>.</p>
<p>Here's a simple "main()" which sets up two basic "pages", a root (/) and one which echoes your browser's request headers (/headers/).</p>
<pre class="prettyprint"><code class="language-java">
public class SimpleHTTPService {

    public static void main(String[] args) throws IOException {
        HttpServer server = HttpServerProvider.provider().createHttpServer(new InetSocketAddress(8080), 0);

        server.createContext("/", new HttpHandler() {
            @Override
            public void handle(HttpExchange he) throws IOException {
                byte[] output = "<h1>Hello world!</h1>".getBytes();
                he.sendResponseHeaders(200, output.length);
                he.getResponseBody().write(output);
            }
        });

        server.createContext("/headers", new HttpHandler() {
            @Override
            public void handle(HttpExchange he) throws IOException {
                StringBuilder result = new StringBuilder("<h1>Request Headers</h1>");
                for (Entry< String, List< String>> header : he.getRequestHeaders().entrySet()) {
                    result.append(String.format("<dl><dt>%s</dt>", header.getKey()));
                    for (String val : header.getValue()) {
                        result.append(String.format("<dd>%s</dd>", val));
                    }
                    result.append("</dl>");
                }

                byte[] output = result.toString().getBytes();
                he.sendResponseHeaders(200, output.length);
                he.getResponseBody().write(output);
            }
        });

        server.setExecutor(Executors.newCachedThreadPool());

        server.start();

        System.out.println("HTTP Listening on port " + server.getAddress().getPort());
    }
}</code></pre>
<p>Running this as-is will allow you to load up the URLs <code>http://localhost:8080/</code> and <code>http://localhost:8080/headers/</code> and see some output generated by the two registered contexts.</p>
<p>I've defined simple anonymous inner class contexts here, as it's easy to play with, but obviously you can go wild and develop proper structures for these. </p>
<p>Combined with something like <a href="http://freemarker.org/">FreeMarker</a>, and you've got a pretty neat way to deploy simple stand-alone HTTP applications written in Java with minimal external dependencies.</p>
<p>It's also extremely useful for creating mock-ups services for use in unit tests for HTTP clients.</p>
